[TOC]

>快速理解：JS的作用域链使得内部函数可以读取外部的变量反之不可行，但是如果要实现这点就需要使用闭包，
>
>参考：
>
>https://www.cnblogs.com/sandaizi/p/11582488.html

## 执行上下文

当一段 JavaScript 代码在运行的时候，它实际上是运行在**执行上下文**中。下面3种类型的代码会创建一个新的执行上下文：

- `全局上下文`是为运行代码主体而创建的执行上下文，也就是说它是为那些存在于JavaScript 函数之外的任何代码而创建的。
- `函数上下文`每个函数会在执行的时候创建自己的执行上下文。
- 使用 `eval()` 函数也会创建一个新的执行上下文。

每一个上下文在本质上都是一种作用域层级。每个代码段开始执行的时候都会创建一个新的上下文来运行它，并且在代码退出的时候销毁掉

## 作用域（Scope）的概念

作用域指一个变量的作用范围。在js中，一共有三种作用域：

- 全局作用域
- 函数作用域
- 块作用域

### 全局作用域

直接编写在script标签中的JS代码，都在全局作用域。

声明在任何函数之外的顶层作用域的变量

- 全局作用域在页面打开时创建，在页面关闭时销毁。
- 在全局作用域中有一个全局对象window，它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用。

在全局作用域中：

- 创建的**变量**都会作为window对象的属性保存。`window.变量`
- 创建的**函数**都会作为window对象的方法保存。`window.函数`(全局作用域的函数也就是 window 的方法--函数和方法没有本质区别)

全局作用域中的变量都是全局变量，在页面的任意的部分都可以访问的到。


### 函数作用域

**函数作用域**

- 变量和函数生效的区域。作用域在**函数定义**时，就已经确定了，函数执行完毕，作用域销毁。
- 在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量。
  - 当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用（**就近原则**）。如果没有则向上一级作用域中寻找，如果上一级没有就再往上找，直到找到全局作用域（套娃儿）；如果全局作用域中依然没有找到，则会报错 ReferenceError。
  - 在函数中要访问全局变量可以使用window对象。（比如说，全局作用域和函数作用域都定义了变量a，如果想访问全局变量，可以使用`window.a`）

- 当函数内部的变量被另外一个函数所引用，那么这个函数的变量将不会在执行完毕后销毁。

**提醒1：**

在函数作用域也有声明提前的特性：

- 使用var关键字声明的变量，会在函数中所有的代码执行之前被声明
- 函数声明也会在函数中所有的代码执行之前执行

因此，在函数中，没有var声明的变量都是**全局变量**，而且并不会提前声明。

举例1：

```javascript
var a = 1;
var b = 1; 

function foo() {
  var a = "我是函数中变量 a";
  console.log(a);//"我是函数中变量 a"
  console.log(window.a)//1
  b = 2;     // 此处的b相当于window.b
}
foo();
console.log(b);   //打印结果是2
```

上方代码中，foo()的打印结果是`1`。如果去掉第一行代码，打印结果是`Uncaught ReferenceError: a is not defined`

**提醒2：**定义形参就相当于在函数作用域中声明了变量。

```javascript
function fun6(e) { // 这个函数中，因为有了形参 e，此时就相当于在函数内部的第一行代码里，写了 var e;
	console.log(e);
}

fun6();  //打印结果为 undefined
fun6(123);//打印结果为123
```

###  块作用域

被`let` 和 `const`关键字定义的变量，如果被一个大括号 { } 括住，那么这个大括号就是一个代码块，大括号括住的这些变量就形成了一个块作用域

```javascript
{
  let a = 1;
  console(a);
}
console(a); // 报错
function showA() {
	console.log(a) // 报错
}
```

## 声明提前

### 变量的声明提前（变量提升）

使用var关键字声明的变量（ 比如 `var a = 1`），**会在所有的代码执行之前被声明**（但是不会赋值），但是如果声明变量时不是用var关键字（比如直接写`a = 1`），则变量不会被声明提前。

举例1：

```javascript
console.log(a);//undefined （说明变量 a 被提前声明了，只是尚未被赋值）
var a = 123;
```

举例2：

```javascript
console.log(a);
a = 123;   //此时a相当于window.a
```

程序会报错：

![img](http://img.smyhvae.com/20180314_2136.png)

### 函数的声明提前

**函数声明**：

使用`函数声明`的形式创建的函数`function foo(){}`，**会被声明提前**。

也就是说，整个函数会在所有的代码执行之前就被**创建完成**，所以可以在函数声明之前调用函数。

代码举例：

```javascript
fn1();  // 虽然 函数 fn1 的定义是在后面，但是因为被提前声明了， 所以此处可以调用函数

function fn1() {
	console.log('我是函数 fn1');
}
```

**函数表达式**：

使用`函数表达式`创建的函数`var foo = function(){}`，**不会被声明提前**，所以不能在声明前调用。

很好理解，因为此时foo被声明了，且为undefined，并没有把 `function(){}` 赋值给 foo。

所以说，下面的例子，会报错：

![img](http://img.smyhvae.com/20180314_2145.png)

## 作用域链

作用域`本质`上就是程序**存储和访问变量的规则**

作用域链**作用**：决定各级上下文中的代码在访问变量和函数时的顺序（先访问的先入栈，当上下文执行完，对应的变量也推出作用域链）

当一个块或者一个函数嵌套在另一个块或者函数中时，就发生了作用域的嵌套。

<span style="background-color:#BCBCBC">每个函数调用都有自己的上下文。 当代码执行流进入函数时, 函数的上下文被推到一个**上下文栈上**。在函数执行完之后,上下文栈会弹出该函数上下文,将控制权返还给之前的执行上下文。ECMAScript 程序的执行流就是通过这个上下文栈进行控制的。上下文中的代码在执行的时候,会创建变量对象的一个**作用域链(scope chain)** 。<u>这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。</u> 代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数,则其活动对象(activation object)用作变量对象。活动对象最初只有一个定义变量: arguments。 (全局上下文中没有这个变量。 ) 作用域链中的下一个变量对象来自包含上下文,再下一个对象来自再下一个包含上下文。以此类推直至全局上下文;全局上下文的变量对象始终是作用域链的最后一个变量对象。 代码执行时的**标识符解析**是通过沿作用域链逐级搜索标识符名称完成的。 搜索过程始终从作用域链的最前端开始,然后逐级往后,直到找到标识符。 (如果没有找到标识符,那么通常会报错。 )</span>

作用域链的变量访问情况

```javascript
var globalVar = 1;
function middle(){
    var middleVar = 2;
    function inner(){
        var innerVar = 3;
        console.log(innerVar,middleVar,globalVar);//均可访问
    }
    inner();
    console.log(innerVar,middleVar,globalVar);//ReferenceError: innerVar is not defined
}
 middle();
console.log(innerVar,middleVar,globalVar)
```

### 作用域链增强

以下两种情况会在作用域链前端添加一个变量对象

`try/catch `

`With`

## 闭包

定义：闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。闭包是将函数内部和函数外部连接起来的桥梁。

在调用一个函数时,会为这个函数调用创建一个执行上下文,并创建一个作用域链。然后用 arguments 和其他命名参数来初始化这个函数的活动对象。==<u>外部函数的活动对象是内部函数作用域链上的第二个对象</u>==。这个作用域链一直向外串起了所有包含函数的活动对象,直到全局执行上下文才终止。

### 闭包作用/特点：

- 读取函数内部的变量，这些变量的值始终保持在内存中，不会在外层函数调换后被自动清除。
- 变量或参数不会被垃圾回收机制回收 GC。
- 闭包会保留它们包含函数的作用域，所以比其他函数更占用内存。

### 函数作为返回值

```javascript
function test(){
    var a =1;
    //周围的状态：test 作用域
    return function(){
        // 在函数定义时向上查找，而不是在函数调用的地方向上查找
        console.log(a,'a');//1
    }
}
const fn = test()
const a=2;
fn();
```

### 函数作为参数

```javascript
function test(fn) {
    const a = 1;
    fn();//调用函数
}

const a = 2;

function fn() {
    //定义的周围
    console.log('a', a); //2
}

test(fn);
```

### 闭包优点

实现递归

```javascript
function  factorial(num) {
   if(num<= 1) {
       return 1;
   } else {
      return num * factorial(num-1)
   }
}
var anotherFactorial = factorial
factorial = null
anotherFactorial(4)   // 报错 ，因为最好是return num* arguments.callee（num-1）
//arguments.callee指向当前执行函数，但是在严格模式下不能使用该属性也会报错，所以借助闭包来实现


// 使用闭包实现递归
function newFactorial = （function f(num){
    if(num<1) {return 1}
    else {
       return num* f(num-1)
    }
}） //这样就没有问题了，实际上起作用的是闭包函数f，而不是外面的函数newFactorial
```



### 闭包应用

#### 模拟私有变量

#### 偏函数与柯里化

## 内存泄露

导致问题：反应迟缓、崩溃、高延迟....

定义：应用程序不再需要占用内存时，由于某些原因，内存没有被回收。

触发的情况

1. ## 意外的全局变量，没有使用 var 声明或者直接使用了 this（指向全局对象时）
2. 被遗忘的计时器或回调函数
3. 脱离 DOM 的引用
4. 闭包

## LHS和RHS查询

LHS(`Left-hand Side`)引用和RHS(`Right-hand Side`)引用。通常是指等号（赋值运算）的左右边的引用。

```javascript
console.log(a);
```

这里对a的引用是一个`RHS引用`，因为这里a并没有赋予任何值，我们只是想`查找并取得a的值`，然后将它打印出来。

```javascript
a = 2;
```

这里对a的引用是一个`LHS引用`，因为我们并不关心当前的值是什么，只是想要`为赋值操作找到目标`。





