



## 服务端渲染SSR

>Nuxt 
>
>基于 Vue

Server Side Render，是指一种渲染方式，在浏览器请求页面URL的时候，服务端将我们需要的HTML文本组装好，并返回给浏览器，这个HTML文本被浏览器解析之后，不需要经过 JavaScript 脚本的执行，即可直接构建出希望的 DOM 树并展示到页面中。

### SSR优点相比于 SPA？

1. 更快的响应时间，相对于客户端渲染，服务端渲染在浏览器请求URL之后已经得到了一个带有数据的HTML文本，浏览器只需要解析HTML，直接构建DOM树就可以。
2. 有利于 SEO ，可以将 SEO 的关键信息直接在后台就渲染成 HTML，而保证搜索引擎的爬虫都能爬取到关键数据，然后在别人使用搜索引擎搜索相关的内容时，你的网页排行能靠得更前，这样你的流量就越高。

<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9cc9144eb5049d5b7fcac540961d2ec~tplv-k3u1fbpfcp-watermark.awebp">

左侧Source部分就是我们所编写的源代码，所有代码有一个公共入口，就是app.js，紧接着就是服务端的入口 （entry-server.js）和客户端的入口（entry-client.js）。当完成所有源代码的编写之后，我们通过webpack的构建，打包出两个bundle，分别是server bundle和client bundle；当用户进行页面访问的时候，先是经过服务端的入口，将vue组建组装为html字符串，并混入客户端所访问的html模板中，最终就完成了整个ssr渲染的过程。

### SPA

单页面应用在访问时会将所有的文件进行加载，仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。

SPA应用程序只有一个html文件，在vue中可以通过 vue-router 来局部切换组件,而非刷新整个页面,来实现无刷新切换页面的技术。



**优点**

1. 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染； 
2. 基于上面一点，SPA 相对对服务器压力小； 
3. 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理； 

**缺点**

1. 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
2. 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理； 
3. SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。搜索引擎只认识`html`里的内容，不认识`js`的内容，而单页应用的内容都是靠`js`渲染生成出来的，搜索引擎不识别这部分内容，也就不会给一个好的排名，会导致SPA应用做出来的网页在百度和谷歌上的排名差。

### MPA

`MPA`多页面应用 `MultiPage Application` ，指有多个独立页面的应用（多个html页面），每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。

| 对比项   | SPA  | MPA  |
| -------- | ---- | ---- |
| 页面切换 | 快   | 慢   |
| 用户体验 | 好   |      |
| 首屏加载 | 慢   | 快   |
| SEO      | 差   | 好   |

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47db831bffcd40349464396ef73901d7~tplv-k3u1fbpfcp-watermark.awebp?">

## http1.0&http1.1&2.0的区别

影响 HTTP 网络请求的因素主要有两个：__带宽和延迟__。

__延迟__

- 浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。
- DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。这个通常可以利用==DNS缓存结果== 来达到减少这个时间的目的。
- 建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。

HTTP1.0最早在网页中使用是在**1996年**，那个时候只是使用一些较为简单的网页上和网络请求上，

HTTP1.1则在**1999年**才开始广泛应用于现在的各大浏览器网络请求中，同时**HTTP1.1也是当前使用最为广泛的HTTP协议**

>参考
>
>https://segmentfault.com/a/1190000016496448



| 比较项   | 1.0                      | 1.1                                             | 2.0          | 备注                                                         |
| -------- | ------------------------ | ----------------------------------------------- | ------------ | ------------------------------------------------------------ |
| 长连接   | keep-alive               | 默认支持                                        |              | 长链接：即在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟 |
|          |                          |                                                 | 支持多路复用 |                                                              |
| 宽带优化 |                          |                                                 |              |                                                              |
| 缓存处理 | if-Modified-Since,Expire | Etag,if-Unmodified-Since,If-Match,If-None-Match |              |                                                              |
|          |                          |                                                 |              |                                                              |

## 为什么1.1会发生头阻塞

头阻塞？

## 浏览器并发执行数（6-8个，Chrome是8个）
## ⭐️⭐️状态码

### 重定向：301、302、303、307、308区别以及使用情况

> 参考
>
> https://blog.csdn.net/weixin_43487782/article/details/114882881
>
> https://blog.csdn.net/IT_DREAM_ER/article/details/116242973

- 301 和 308 被用于当一个资源被**永久的迁移到新的地址**上的情况。

308：当接收到308的响应时，客户端必须在新地址上重复同样的请求，而301重定向会改变请求的方法，将POST方法改变成GET方法来请求新地址。

301：当收到 301 响应，后台会在响应头中返回 `Location` 字段，其中包含了需要重定向的新地址，浏览器接收响应之后会重定向到这个地址。如果没有额外指定，这个响应默认**会被浏览器缓存**。当下次再请求的时候，浏览器不会向服务器发送请求，而是直接从缓存中获取需要重定向的新地址。**但是**如果服务器需要获取用户的点击数，如果浏览器缓存了长链接，服务器就没办法获取到短链接的点击数了，所以<u>一般不采用 301</u>

- 302，303和307状态码被用于当资源需要**临时重定向到新URL上**的情况，这意味着此重定向只是临时起作用且不应该被缓存。

302：这个响应默认**不会被浏览器缓存**，只有在 `Cache-Control` 或 `Expires` 中进行指定的情况下，这个响应才会缓存。新的临时性的 URI 应该在响应头的 `Location` 字段返回。没有指定缓存的情况下，当下次再请求的时候，浏览器会继续发送请求给服务器。



|                               | 状态码  | 状态码英文名称                  | 中文描述                                                     | 相关头部字段                                               | http                                     |
| ----------------------------- | :------ | :------------------------------ | :----------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
|1XX|     /                 |/                                                                                                                     |信息，服务器收到请求，需要请求者继续执行操作|||
|                               | 100     | Continue                        | 继续。客户端应继续其请求 | `Expect` |  |
|                               | 101     | Switching Protocols             | 切换协议。服务器根据客户端的请求（`update`）切换协议，切换到更高级的协议。 |  |  |
|2XX|     /                  |    /                                                                                                                |成功，操作被成功接收并处理|||
|                               | 200 | OK                              | 请求成功。一般用于GET与POST请求                              |                               |                               |
|                               | 201 | Created                         | 已创建。成功请求并创建了新的资源POST                         | `Location`               |                          |
|                               | 202     | Accepted                        | 已接受。已经接受请求，但未处理完成。                         |                            |                            |
|                               | 203     | Non-Authoritative Information   | 非授权信息。请求成功。但返回的实体信息不在原始的服务器，而是一个副本。 |  |  |
|                               | 204 | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |  |  |
|                               | 205     | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |  |  |
|                               | 206     | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                        |                         |                         |
|3XX|     /                  | /                                                                                                                    |重定向，需要进一步的操作以完成请求|||
|                               | 300     | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |  |  |
|                               | 301     | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URL，浏览器会自动定向到新URL。今后任何新的请求都应使用新的URI代替。 | `Location` |  |
|                               | 302     | Found                           | 临时移动。与301类似。但资源只是临时被移动。将来的访问客户端应继续使用原有URL。 | `Location`、`Cache-Control`、 `Expires` | http1.0 |
|                               | 303     | See Other                       | 查看其它地址。http1.1303与 http1.0302实现相同的功能，重定向客户端的 POST 请求,在它后面跟上一个 GET 请求。 | `Location`     | http1.1 |
|  | 304     | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 | `ETag`、`If-None-Match` |  |
|                               | 305     | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                       |                        |                        |
|                               | 306     | Unused                          | 已经被废弃的HTTP状态码                                       |                                        |                                        |
|                               | 307     | Temporary Redirect              | 临时重定向。与301类似。使用GET请求重定向。                  | `Location`           | http1.1    |
|4XX|     /                         |/                                                                                                                    |客户端错误，请求包含语法错误或无法完成请求|||
|                               | 400     | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |                          |                          |
|                               | 401     | Unauthorized                    | 请求要求用户的身份认证                                       | `WWW-Authenticate`                     |                                        |
|                               | 402     | Payment Required                | 保留，将来使用                                               |                                                |                                                |
|                               | 403     | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求，这个状态码通常是在服务器不想说明拒绝原因的时候使用的 |                |                |
|                               | 404     | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |  |  |
|                               | 405     | Method Not Allowed              | 客户端请求中的方法被禁止，                             | `Allow`                            |                                      |
|                               | 406     | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |                    |                    |
|                               | 407     | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |  |  |
|                               | 408     | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |                      |                      |
|                               | 409     | Conflict                        | 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 |  |  |
|                               | 410     | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |  |  |
|                               | 411     | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       | `Content-Length` |        |
|                               | 412     | Precondition Failed             | 客户端请求信息的先决条件错误，发送条件请求其中一个失败时               | `Expect`                         |                                  |
|                               | 413     | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |  |  |
|                               | 414     | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               | `Retry-After` |                |
|                               | 415     | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |                              |                              |
|                               | 416     | Requested range not satisfiable | 客户端请求的范围无效                                         |                                          |                                          |
|                               | 417     | Expectation Failed              | 服务器无法满足Expect的请求头信息                             | `Expect`                     |                              |
|5XX|     /                     |/                                                                                                                      |服务器错误，服务器在处理请求的过程中发生了错误|||
|                               | 500     | Internal Server Error           | 服务器内部错误，无法完成请求                                 |                                  |                                  |
|                               | 501     | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |                          |                          |
|                               | 502     | Bad Gateway                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |  |  |
|                               | 503     | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 | `Retry-After` |  |
|                               | 504     | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求，408      |            |            |
|                               | 505     | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |                |                |



## 短链接和长链接

### 短连接 

- 操作：连接->传输数据->关闭连接 

 HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。 
 也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。 

### 长连接  

- 操作：连接->传输数据->保持连接 -> 传输数据-> 。。。 ->关闭连接。 

 长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。 

 http的长连接 
 HTTP也可以建立长连接的，使用`Connection:keep-alive`，HTTP 1.1默认进行持久连接。HTTP1.1和HTTP1.0相比较而言，最大的区别就是增加了持久连接支持(貌似最新的 http1.0 可以显示的指定 keep-alive),但还是无状态的，或者说是不可以信任的。 



## 请求方法

HTTP定义了与服务器交互的方法

- GET：从指定的资源请求数据

- Head：与 Get 返回的头部一样只是不返回实体

在不获取资源的情况下了解资源的情况(比如,判断其类型) ; 

通过查看响应中的状态码,看看某个对象是否存在; 

通过查看首部,测试资源是否被修改了。

- POST：想指定的资源提交要被处理的数据，主要是表单
- PUT：请求写入服务器，允许用户对内容进行修改
- Trace：客户端发起一个请求时,这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的 HTTP 请求。TRACE 方法允许客户端在最终将请求发送给服务器时,看看它变成了什么样子。
- Option：OPTIONS 方法请求 Web 服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法,或者对某些特殊资源支持哪些方法。 (有些服务器可能只支持对一些特殊类型的对象使用特定的操作) 。这为客户端应用程序提供了一种手段,使其不用实际访问那些资源就能判定访问各种资源的最优方式。响应如，`Allow: GET, POST, PUT, OPTIONS`
- DELETE：请服务器删除请求 URL 所指定的资源，但是操作不一定会被执行

### Get 和 Post对比

|                      | GET                                                    | POST                                                         |
| :------------------- | :----------------------------------------------------- | :----------------------------------------------------------- |
|                      | 请求会显示在地址栏发送，安全性低，不适用于处理敏感数据 | 在 HTTP 消息主体中发送                                       |
| 后退按钮/刷新        | 无害                                                   | 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。     |
| 能否被收藏为书签     | 是                                                     | 否                                                           |
| 能否缓存             | 是                                                     | 否                                                           |
| 编码类型             | application/x-www-form-urlencoded                      | application/x-www-form-urlencoded or multipart/form-data。为二进制数据使用多重编码。 |
| 历史保留在浏览器     | 是                                                     | 否                                                           |
| **对数据长度的限制** | 数据量受限                                             | 无限制，上传文件只能 POST                                    |
| 对数据类型的限制     | 只允许 ASCII 字符。                                    | 没有限制。也允许二进制数据。                                 |
| **安全性**           | 安全性差                                               | 安全er，参数不会被保存在浏览器历史或 web 服务器日志中。      |
| **可见性**           | 数据在 URL 中对所有人都是可见的。                      | 数据不会显示在 URL 中。                                      |
|                      | GET 是 form 表单的默认方法                             |                                                              |

`application/x-www-form-urlencoded`是浏览器默认的编码格式。对于Get请求，是将参数转换`?key=value&key=value`格式，连接到url后



## ⭐️⭐️浏览器缓存

```
参考
https://juejin.cn/post/6844903838768431118
https://limeii.github.io/2018/11/web-cache/
https://juejin.cn/post/6947936223126093861
```

❓浏览器使用缓存时从哪里取？

**浏览器缓存**其实就是指在本地使用的计算机中开辟一个内存区，同时也开辟一个硬盘区作为数据传输的缓冲区，然后用这个缓冲区来暂时保存用户以前访问过的信息。



❓这些缓存有区别吗？

**浏览器缓存位置一般分为四类：** Service Worker-->Memory Cache-->Disk Cache-->Push Cache。



❓根据缓存位置不同，他们之间有什么区别？

1）Service worker

是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。



2）Memory Disk

`200 form memory cache` 
不访问服务器，直接从内存中读取缓存。

缓存内容：主要包含的是当前中页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。

读取内存中的数据比磁盘快，读取高效，持续性很短，会随着进程的释放而释放。浏览器关闭后，数据将不存在（资源被释放掉了），再次打开相同的页面时，不会出现from memory cache。



3）Disk cache

`200 from disk cache`

不访问服务器，直接从硬盘中读取缓存。

缓存内容：什么都能存

关闭浏览器后，数据依然存在，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache。



4）Push Cache 推送缓存

 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。

### **强缓存**

强缓存是不会向服务器发送请求，直接从缓存中读取资源

#### Expires 、 Cache-Control 和 pragma 用来标识强缓存

`Expires`：过期时间，如果设置了时间，则浏览器会在设置的时间内直接读取缓存，不再请求服务器。
`Cache-Control`：同时有 Expires 和 Cache-Control 的时候，**Cache-Control 的优先级要比 Expires 要高**，比如`Cache-Control: max-age=300`（秒），表示这个请求的返回时间（浏览器会记录该时间）的五分钟之内再次加载该资源，就会从缓存中读取该文件，无需再次请求。主要取值为：

public：资源客户端和服务器都可以缓存。

privite：资源只有客户端可以缓存。

no-cache：客户端缓存资源，但是是否缓存需要经过协商缓存来验证。

no-store：不使用缓存。

max-age：缓存保质期。

<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f169e913e244d52a44ff1e4185cb9ce~tplv-k3u1fbpfcp-watermark.awebp">

`pragma`：禁用网页缓存，取值为`no-cache`，效果和 Cache-control 的 no-catch效果一样。



### **协商缓存**

协商缓存是指在强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识来决定是否使用缓存，服务器会根据这个请求的请求头的一些参数来判断是否命中协商缓存，如果命中，则返回`304`状态码并带上新的响应头通知浏览器从缓存中读取资源；

#### ETag / Last-Modified和Last-Modifed/If-Modified-Since用来标识协商缓存

- Etag/If-None-Match：
  `Etag：`HTTP 1.1属性，它是由服务器（Apache或者其他工具）生成返回给前端，用来**帮助服务器控制Web端的缓存验证**。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。
  `If-None-Match`当资源过期时，浏览器发现响应头里有Etag，则再次向服务器请求时带上请求头if-none-match(值是Etag的值)。服务器收到请求进行比对，决定返回200或304

- Last-Modifed/If-Modified-Since：
  `Last-Modified`：浏览器向服务器发送资源最后的修改时间
  `If-Modified-Since`当资源过期时（浏览器判断Cache-Control标识的max-age过期），发现响应头具有Last-Modified声明，则再次向服务器请求时带上头if-modified-since，表示请求时间。服务器收到请求后发现有if-modified-since则与被请求资源的最后修改时间进行对比（Last-Modified）,若最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP `200` OK;若最后修改时间较旧（小），说明资源无新修改，响应HTTP `304 `走缓存。

  

  浏览器缓存，第一次访问

  <img src="https://limeii.github.io/assets/images/posts/web/web-cache03.png" style="zoom:80%;" >

  第二次访问但缓存还有效，返回304
  <img src="https://limeii.github.io/assets/images/posts/web/web-cache06.png" style="zoom:80%;" >

  缓存失效，返回200和请求结果
  <img src="https://limeii.github.io/assets/images/posts/web/web-cache07.png" style="zoom:80%;" >

### ⭐️熟记⭐️总结：请求整体流程

1. **第一次进入页面**，请求服务器，然后服务器进行应答，浏览器会根据response Header来判断是否对资源进行缓存，如果有`expires`、`pragma`或者`cache-control`字段，代表这是强缓存，浏览器就会把资源缓存在`memory cache `或` disk cache`中。

2. **第二次请求时**，浏览器判断请求参数，如果符合强缓存条件就直接返回状态码`200`，从本地缓存中拿数据。否则把响应参数存在request header请求头中，看是否符合协商缓存，符合则返回状态码`304`，不符合则服务器会返回全新资源。如下图所示。

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca00bff3081e4cfd993a8f252f4fa23a~tplv-k3u1fbpfcp-watermark.awebp">



## 首部

- 通用首部：提供了与报文相关的最基本的信息，不论报文是何类型,都为其提供一些有用信息。

- 请求首部：请求首部是只在请求报文中有意义的首部。用于说明是谁或什么在发送请求、请求源自何处,或者客户端的喜好及能力。服务器可以根据请求首部给出的客户端信息, 试着为客户端提供更好的响应

- 响应首部：响应报文有自己的响应首部集。响应首部为客户端提供了一些额外信息,比如谁在发送响应、响应者的功能,甚至与响应相关的一些特殊指令。这些首部有助于客户端处理响应,并在将来发起更好的请求。

- 实体首部：请求和响应报文中都可能包含实体部分,所以在这两种类型的报文中都可能出现这些首部。
  实体首部提供了有关实体及其内容的大量信息,从有关对象类型的信息,到能够对资源使用的各种有效的请求方法。总之,实体首部可以告知报文的接收者它在对什么进行处理。

## ⭐️通用首部

提供了与报文相关的最基本的信息，不论报文是何类型,都为其提供一些有用信息。

|                | 首部              | 描述                                                         | 相关                                       |
| -------------- | ----------------- | ------------------------------------------------------------ | ------------------------------------------ |
| 通用信息性首部 |                   | 对请求和响应报文通用，都是同一个意思                         |                                            |
|                | Connection        | 设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与`Expires`相反，时间是相对于请求的时间。==表示是否需要持久连接。（HTTP 1.1默认进行持久连接）== | http1.0：keep-alive、http1.1默认开启长链接 |
|                | Date              | 报文创建时间                                                 |                                            |
|                | MIME-Version      | MIME 版本                                                    |                                            |
|                | Trailer           | 分块传输编码方式                                             |                                            |
|                | Transfer-Encoding | 接收端为了保证报文的可靠传输，对报文采取什么编码方式         |                                            |
|                | Updata            |                                                              |                                            |
|                | Via               | 报文经过的中间点（代理、网关）                               |                                            |
| 通用缓存首部   |                   |                                                              |                                            |
|                | Cache-Control     |                                                              |                                            |
|                | Pragma            | 不专用于缓存                                                 |                                            |



## ⭐️请求首部


|              | 字段                | 说明                                                         | 举例                                                    | 相关知识      |
| ------------ | ------------------- | ------------------------------------------------------------ | ------------------------------------------------------- | ------------- |
| 信息首部     |                     |                                                              |                                                         |               |
|              | Host                | 指定请求的服务器的域名和端口号                               | Host: www.zcmhi.com:80                                  |               |
|              | From                | 发出请求的用户的Email                                        | From: user@email.com                                    |               |
|              | Referer             | 先前网页的地址，当前请求网页紧随其后,即来路                  | Referer: http://www.zcmhi.com/archives/71.html          |               |
| Accept首部   |                     | 客户端将想要什么、可以使用什么不想要什么告诉服务器           |                                                         |               |
|              | Accept              | 浏览器可以接收的类型                                         | Accept:text/html,image/*                                |               |
|              | Accept-Charset      | 浏览器可以接受的字符编码集。                                 | Accept-Charset: iso-8859-5                              |               |
|              | Accept-Encoding     | 指定浏览器可以支持的web服务器返回内容压缩编码类型。          | Accept-Encoding: compress, gzip                         |               |
|              | Accept-Language     | 浏览器可接受的语言                                           | Accept-Language: en,zh                                  |               |
|              | Accept-Ranges       | 可以请求网页实体的一个或者多个子范围字段                     | Accept-Ranges: bytes                                    |               |
|              | TE                  |                                                              |                                                         |               |
| 条件请求首部 |                     | 客户端希望为请求加上限制时使用                               |                                                         |               |
|              | Expect              | 请求的特定的服务器行为                                       | Expect: 100-continue                                    |               |
|              | If-Match            | 只有请求内容与实体相匹配才有效                               | If-Match: “737060cd8c284d8af7ad3082f209582d”            |               |
|              | If-Modified-Since   | 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 | If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT        |               |
|              | If-Unmodified-Since | 只在实体在指定时间之后未被修改才请求成功                     | If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT      |               |
|              | If-None-Match       | 服务器根据浏览器的if-None-match判断是否命中缓存              | If-None-Match: “737060cd8c284d8af7ad3082f209582d”       |               |
|              | If-Range            | 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag | If-Range: “737060cd8c284d8af7ad3082f209582d”            |               |
|              | Range               | 只请求实体的一部分，指定范围                                 | Range: bytes=500-999                                    |               |
| 安全请求首部 |                     | 可以对请求进行质询/响应认证                                  |                                                         | 质询/响应机制 |
|              | Authorization       | 客户端提供的身份认证                                         | Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==       | 授权 `401`    |
|              | Cookie              | HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 | Cookie: $Version=1; Skin=new;                           |               |
|              | Cookie2             | 用来说明请求段支持的 Cookie 版本                             |                                                         |               |
| 代理请求首部 |                     |                                                              |                                                         |               |
|              | Max-Forwards        | 限制信息通过代理和网关传送的时间                             | Max-Forwards: 10                                        |               |
|              | Proxy-Authorization | 和 `Authorization`相同，连接到代理的授权证书                 | Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== |               |
|              | Proxy-Connection    | 与 `Connection` 相同，代理建立连接时使用                     |                                                         |               |

## ⭐️响应首部

|              | 字段               |                                | 说明                            | 相关状态码 |
| ------------ | :----------------- | ------------------------------ | :------------------------------ | ---------- |
| 响应信息首部 |                    |                                |                                 |            |
|              | Warning            | 关于消息实体的警告信息         | Warn: 199 Miscellaneous warning |            |
|              | Age                | 响应持续时间                   |                                 |            |
|              | Public             |                                |                                 |            |
|              | Server             | 服务器名字和版本               |                                 |            |
|              | Title              |                                |                                 |            |
|              | Retry-After        |                                |                                 |            |
| 协商首部     |                    |                                |                                 |            |
|              | Accept-Ranges      | 服务器可接受范围类型           |                                 |            |
|              | Vary               |                                |                                 |            |
| 安全响应首部 |                    |                                |                                 |            |
|              | Set-Cookie         |                                |                                 |            |
|              | Set-Cookie2        |                                |                                 |            |
|              | Proxy-Authenticate | 来自代理的对客户端的质询列表   |                                 |            |
|              | WWW-Authenticate   | 来自服务器的对客户端的质询列表 |                                 | 质询`401`  |

## ⭐️实体首部

请求和响应报文中都可能包含实体部分,所以在这两种类型的报文中都可能出现这些首部。
实体首部提供了有关实体及其内容的大量信息,从有关对象类型的信息,到能够对资源使用的各种有效的请求方法。总之,实体首部可以告知报文的接收者它在对什么进行处理。

|                |                  |                                                       |                                                              |                   |
| -------------- | :--------------- | ----------------------------------------------------- | :----------------------------------------------------------- | ----------------- |
| 实体信息性首部 |                  |                                                       |                                                              |                   |
|                | Location         | location: http://www.lks.cn/index.html                | 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。 | `301\302\303\307` |
|                | Allow            | 服务器支持哪些请求方法（如GET、POST等）。             |                                                              | `405`             |
| 内容首部       |                  |                                                       |                                                              |                   |
|                | Content-Encoding | 服务器发送的压缩编码方式。                            | Content-Encoding:gzip                                        |                   |
|                | Content-Base     |                                                       |                                                              |                   |
|                | Contend-Range    |                                                       |                                                              |                   |
|                | Content-MD5      |                                                       |                                                              |                   |
|                | Content-Length   | 服务器发送的字节码长度。                              | Content-Length:80                                            |                   |
|                | Content-Type     | 请求的与实体对应的MIME信息                            | Content-Type: image/jpeg; charset=UTF-8                      |                   |
|                | Content-language | 服务器发送内容的语言和国家名                          | Content-language:zh-cn                                       |                   |
|                | Content-Location | 资源实际位置                                          |                                                              |                   |
| 实体缓存首部   |                  |                                                       |                                                              |                   |
|                | Expires          | Expires:-1<br />expires:Fri, 14 Apr 2017 10:47:02 GMT | 资源过期时间，GMT格式时间字符串，-1表示 永远过期             | 强缓存`304`       |
|                | Last-Modified    | Tue, 11 Jul 2000 18:23:51                             | 服务器最后一次修改的时间                                     | 协商缓存`304`     |
|                | ETag             | ETag：“ihfdgkdgnp98hdfg”                              | 保证每一个资源都是唯一的，资源变化会导致ETag变化，**协商缓存** | 协商缓存`304`     |



```
MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。
MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。
```



## DNS域名解析

==域名解析==

**域名解析**是把域名指向网站空间IP，让人们通过注册的域名可以方便地访问到网站的一种服务。**就是域名到IP地址的转换过程。由**DNS服务器**完成。

DNS 服务器为一个联机分布式数据库系统

- 作用：将域名与对应的 Ip转换的**服务器**
- 特征：DNS 中保存了一张域名与对应 IP 地址的表，一个域名对应一个IP 地址，一个 IP 地址可以对应多个域名

- gTLD（generic top-level domains）：==.com==、==.net==

  

  ![](https://pic2.zhimg.com/80/e5143bc08d4ec9d7f210522c7e540f4d_1440w.jpg?source=1940ef5c)

  

  ![Snipaste_2021-05-22_22-05-04](/Users/ynchen/Library/Mobile Documents/com~apple~CloudDocs/1我的同步/笔记/00前端/images/Snipaste_2021-05-22_22-05-04-1799763.png)

  ```note
  [根服务器：管理互联网的主目录，1 个主根在美国，12 个辅根:9 个在美国，2 个在欧洲（英国&瑞典），一个在日本
  ```

==查询方式== ：递归查询和迭代查询

==DNS 解析（3-10）、Http解析流程（1-10）==

当一个用户`m.xyz.com`在地址栏输入`y.abc.com`时，DNS解析有大致十个过程

<span style="color:grey">1. **浏览器**先检查自身缓存中有没有被解析过的这个域名对应的ip地址，如果有，解析结束。同时域名被缓存的时间也可通过TTL属性（Time To Live，生存时间值，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量）来设置。</span>

<span style="color:grey">2. 如果浏览器缓存中没有（专业点叫还没命中），浏览器会检查**操作系统缓存**中有没有对应的已解析过的结果。而操作系统也有一个域名解析的过程。在windows中可通过c盘里一个叫hosts的文件来设置，如果你在这里指定了一个域名对应的ip地址，那浏览器会首先使用这个ip地址。</span>

3. 如果至此还没有命中域名，才会真正的请求**本地域名服务器（LDNS）**`dns.xyz.com`来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约80%的域名解析到这里就完成了。
4. 如果LDNS仍然没有命中，就把请求发给 13 台**根域名服务器**（``.``）请求解析
5. 根域名服务器判断这个域名（.com）是由谁授权管理，返回给LDNS一个所查询域的**顶级服务器gTLD**(`dns.com/.net`)IP。
6. LDNS再发送请求给上一步返回的**顶级域名服务器**
7. 接受请求的顶级域名服务器查找，并返回这个域名对应的权限DNS 服务器地址 (`dns.abc.com`)
8. 权限 DNS 服务器根据**映射关系表**找到目标IP，返回给LDNS
9. LDNS缓存这个域名和对应的IP
10. LDNS把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束

## IP地址/互联网协议地址（Internet Protocol Adress）

- 作用：分配给用户上网使用的互联网协议

- 分类：IPv4、IPv6（v : version）

- ==形式：==
  - IPv4：192.168.0.1 （4组/4 个字节，十进制，32 位(4*8)
  - IPv6：ABCD:EF01:2345:6789:ABCD:EF01:2345:6789（8 组，十六进制，128 位（8*16）		

IPv6 优势（使用的比较少但是有巨大的优势）：
- 空间更大
- 路由表更小
- **组播**支持以及对流支持增强
- 对**自动配置**的支持，失败率降低（连得上网但是上不了）
- 更高的安全性

## 端口号 Port

解释：每个端口对应的是一个服务器的一个业务，访问一个服务器的不同端口相当于访问不同的业务

范围：0-65535

默认端口：==http（80）、https（443）、FTP（20、21）==

>EX类比
>
>域名：上海迪士尼乐园
>
>IP: 上海市浦东新区
>
>端口：乐园海盗船入口

## TCP 

Transmission Control Protocol 传输控制协议

概述：TCP提供一种面向连接的可靠的字节流传输服务，这个过程涉及到三次握手，四次挥手，握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。

- 特点：**面向连接**（收发数据前，必须建立可靠的连接）

- 建立连接基础：三次握手

- 应用场景：数据必须准确无误的收发：HTTP 请求、FTP 文件传输、邮件收发、远程终端接入

- 优点：稳定、重传机制、拥塞控制机制、断开连接

- 缺点：速度慢、效率低、占用资源、容易被攻击（三次握手-->DOS、DDOS 攻击）

- TCP/IP协议组：提供**点对点**的连接机制，指定了数据封装、定址、传输、路由、数据接收的标准

## UDP 

User Data Protocol 用户数据报协议

- 特点：面向无连接（不可靠的协议，无状态传输机制）

- 无连接信息发送机制

- 提供给网络层的IP使用，不进行处理添加UDP头部之后直接发送

- 应用场景：无需确保通讯质量且要求速度快、无需确保信息完整，信息收发、语音通话、直播

- 优点：安全、快速、漏洞少（UDPflood 攻击）

- 缺点：不可靠、不稳定、容易丢包

总结：只要目的源地址、端口号、地址、端口号确定，则可以直接发送信息报文，但不能保证一定能收到或收到完整的数据

## http 和 https

==HTTP==  ：Hyper Text Transfer Protocol 超文本传输协议

>  HTML Hyper Text Markup Language 超文本标记语言

- 定义：客户端和服务器端请求和应答的标准，用于从 Web 服务器传输超文本到本地浏览器的传输协议

  http 协议定义了浏览器怎样向万维网服务器请求万维网文档以及服务器怎样把文档传送给浏览器。
  
- 特点：

  - 使用面向连接的 TCP 作为运输层协议
  - HTTP 协议本身是**无连接**的
  - HTTP 协议是**无状态**的（服务器不记得曾经访问的客户也不记得为其服务的次数）

- HTTP 请求：按照协议规则先向 web 服务器发送的将超文本传输到本地浏览器的请求，建立 TCP 连接，发送 HTTP **请求报文**，服务器收到 HTTP请求报文后，就把所请求的文档作为**响应报文**返回给客户

==HTTPS== ：Hyper Text Transfer Protocol ==Secure== 超文本传输安全协议

-  在 HTTP 基础上加了一层安全层，安全基础是 **SSL/TLS**
   - SSL Secure Sockets Layer 安全套接层
   - TLS Transport Layer Security 传输层安全
   - 为网络通信提供安全及数据完整性的一种安全协议，对网络连接进行加密

==区别== 

1. http 是不安全的（监听和中间人等手段，获取网站账户信息和敏感信息），

   https 可防止被攻击

2. http 协议传输的内容都是<u>明文</u>，直接在 TCP 连接上运行，客户端和服务器都无法验证对方身份

   https 传输内容都被 <u>SSL / TLS 加密</u>，且运行在 SSL / TLS 上， SSL / TLS 运行在 TCP 上，<u>数据传输是安全</u>的

   >⚠️注意
   >
   >http 和 https 都要先建立 TCP 连接，在传输内容时 <u>https 加密</u>，<u>http 不加密</u>直接传输

## HTTPS原理

```
参考 https://segmentfault.com/a/1190000021494676
```


<img src="https://segmentfault.com/img/bVbClUl/view">



## TLS三次握手

```
参考：https://segmentfault.com/a/1190000021494676
```

SSL逐渐被TLS取代，SSL和TLS可以为通信双方提供识别和认证通道，从而保证通信的机密性和数据完整性。在 TLS 握手的过程中，通信双方交换消息以相互验证，相互确认，并确立它们所要使用的加密算法以及会话密钥 (用于对称加密的密钥)。可以说，TLS 握手是 HTTPS 通信的基础部分。

<img src="https://segmentfault.com/img/bVbCCMD/view">



1. **"client hello"消息：**客户端通过发送"client hello"消息向服务器发起握手请求，该消息包含了客户端所支持的 TLS 版本和密码组合以供服务器进行选择，还有一个"client random"随机字符串。
2. **"server hello"消息：**服务器发送"server hello"消息对客户端进行回应，该消息包含了数字证书，服务器选择的密码组合和"server random"随机字符串。
3. **验证：**客户端对服务器发来的证书进行验证，确保对方的合法身份，验证过程可以细化为以下几个步骤：
   1. 检查数字签名
   2. 验证证书链 (这个概念下面会进行说明)
   3. 检查证书的有效期
   4. 检查证书的撤回状态 (撤回代表证书已失效)
4. **"premaster secret"字符串：**客户端向服务器发送另一个随机字符串"premaster secret (预主密钥)"，这个字符串是经过服务器的公钥加密过的，只有对应的私钥才能解密。
5. **使用私钥：**服务器使用私钥解密"premaster secret"。
6. **生成共享密钥**：客户端和服务器均使用 client random，server random 和 premaster secret，并通过相同的算法生成相同的共享密钥 **KEY**。
7. **客户端就绪：**客户端发送经过共享密钥 **KEY**加密过的"finished"信号。
8. **服务器就绪：**服务器发送经过共享密钥 **KEY**加密过的"finished"信号。
9. **达成安全通信：**握手完成，双方使用对称加密进行安全通信。

**数字签名 (digital signature)**：和手写签名类似，是为了确保数据发送者的合法身份，也可以确保数据内容未遭到篡改，保证数据完整性。与手写签名不同的是，数字签名会随着文本数据的变化而变化。具体到数字证书的应用场景，数字签名的生成和验证流程如下：

1. 服务器对证书内容进行信息摘要计算 (常用算法有 SHA-256等)，得到摘要信息，再用私钥把摘要信息加密，就得到了数字签名
2. 服务器把数字证书连同数字签名一起发送给客户端
3. 客户端用公钥解密数字签名，得到摘要信息
4. 客户端用相同的信息摘要算法重新计算证书摘要信息，然后对这两个摘要信息进行比对，如果相同，则说明证书未被篡改，否则证书验证失败

## 

## OSI 七层协议及相应协议和硬件

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png" width="450"/> </div><br>

| #    | 层级       | 协议                                                         |
| ---- | ---------- | ------------------------------------------------------------ |
| 7    | 应用层     | HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP |
| 6    | 表示层     | XDR、ASN.1、SMB、AFP、NCP                                    |
| 5    | 会话层     | ASAP、TLS、SSH、ISO 8337/CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSDsocket |
| 4    | 传输层     | TCP、UDP、RTP、SCTP、SPX、ATP、IL                            |
| 3    | 网络层     | IP、ICMP、IPX、BGP、OSPF、IGRP、EIGRP、APR、RAPR、X.25       |
| 2    | 数据链路层 | 以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP |
| 1    | 物理层     | 线路、无线电、光纤、信鸽                                     |



## 五层协议 

-   **应用层**  ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。

-   **传输层**  ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。
运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为**报文段**；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为**用户数据报**。TCP 主要提供完整性服务，UDP 主要提供及时性服务。

-   **网络层**  ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。

-   **数据链路层**  ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。

-   **物理层**  ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

## CP/IP协议

TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），分别是链路层、网络层、传输层和应用层，相当于五层协议中数据链路层和物理层合并为网络接口层。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/48d79be8-085b-4862-8a9d-18402eb93b31.png" width="250"/> </div><br>

TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。

<div><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/10/7f693d4add34644a6268e0e11bec2cb7~tplv-t2oaga2asx-watermark.awebp"/></div>

### TCP 服务器最大并发链接数多少？



## 三次握手

![Snipaste_2021-05-23_11-29-49](/Users/ynchen/Library/Mobile Documents/com~apple~CloudDocs/1我的同步/笔记/00前端/images/Snipaste_2021-05-23_11-29-49.png)

```
标志位：数据包SYN（Synchronize Sequence Numbers）：同步序列编号ACK（Acknowledgement）：确认字符SYN_SENT：在发送连接请求后等待匹配的连接请求LISTEN：监听TCP 端口的连接请求SYN_RECIEVED:在收到和发送一个连接请求后等待对连接请求的确认ESTABLISHED：代表一个打开的连接，数据可以传送给用户
```

⭐️==总结：==

1. 第一次握手：客户端向服务器发送同步序列编号标志位（序号是 J，SYNJ），并进入等待服务器确认状态
2. 服务器收到来自客户端的同步序列编号标志位J SYNJ，服务端会确认该数据包以收到并发送确认字符标志位（序号是 J+1，ACKJ+1）和 同步序列标志位（序号是 K），服务器进入请求接收并等待客户端确认状态。
3. 第三次握手：客户端进入连接建立状态后，向服务器发送 ACK 标志位（序号是 K+1）确认客户端已收到建立连接确认，服务器收到 ACK 标志位后，服务端进入连接已建立状态

## 四次挥手

数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，假设客户端主动关闭，服务器被动关闭。

<div><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/8/16da9fd28b49f652~tplv-t2oaga2asx-watermark.awebp"></div>

- 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 `FIN_WAIT1` 状态。 即发出**连接释放报文段**（FIN=1，序号seq=u），并<u>停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认</u>。
- 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。 即服务端收到连接释放报文段后即发出**确认报文段**（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。
- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态。 即服务端没有要向客户端发出的数据，服务端发出**连接释放报文段**（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。
- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 `TIME_WAIT` 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 `CLOSED` 状态。 即客户端收到服务端的连接释放报文段后，对此发出**确认报文段**（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

[参考](https://juejin.cn/post/6844903958624878606#heading-6)

## ⭐️浏览器进程

>进程&线程
>
>**进程**是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
>
>**线程**是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
>
>浏览器：
>
>- 浏览器是多进程的
>- 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）
>- 每打开一个Tab页，就相当于创建了一个独立的浏览器进程。
>- **Browser进程**：浏览器的主进程（负责协调、主控），只有一个。作用有：

1. **Browser 浏览器进程**

- 负责浏览器界面显示，与用户交互。如前进，后退等

- 负责各个页面的管理，创建和销毁其他进程
- 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上
- 网络资源的管理，下载等

2. **第三方插件进程**：每种类型的插件对应一个进程，仅当使用该插件时才创建

3. **GPU进程**：最多一个，用于3D绘制等

4. ⭐️**浏览器渲染进程（浏览器内核、Renderer 进程）**：默认每个Tab页面一个进程，互不影响。主要作用为页面渲染，脚本执行，事件处理等

- 页面的渲染，JS的执行，事件的循环，都在这个进程内进行

### **Renderer进程（多线程）**

1. GUI渲染线程
   - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
   - 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
   - ❗️注意，**GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中**等到JS引擎空闲时**立即被执行。
2. JS引擎线程
   - 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
   - JS引擎线程负责解析Javascript脚本，运行代码。
   - JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
   - ❗️同样注意，**GUI渲染线程与JS引擎线程是互斥的**，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。
3. 事件触发线程
   - 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
   - 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
   - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
   - 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）
4. 定时触发器线程
   - 传说中的`setInterval`与`setTimeout`所在线程
   - 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
   - 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
   - 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。
5. 异步http请求线程
   - 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
   - 将检测到状态变更时，如果设置有回调函数，异步线程就**产生状态变更事件**，将这个回调再放入事件队列中。再由JavaScript引擎执行。



## ⭐️浏览器页面渲染流程

1. 解析HTML，构建DOM树
2. 解析CSS，生成CSS规则树(CSSOM)
3. 合并DOM树和CSS规则，生成render树
4. 布局render树**Layout/reflow**，负责各元素尺寸、位置的计算，设置伪类的元素 `content：‘’`会出现在 layout 树中，不会在 DOM 树
5. 绘制render树**paint**，绘制页面像素信息，按照 z-index 顺序绘制
6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成**composite**，显示在屏幕上

![img](https://segmentfault.com/img/remote/1460000013662138/view)

![image-20211014145716557](./images/image-20211014145716557.png)

```
请求页面，客户端返回html，当解析到link时请求css并继续，解析到script时请求JS，阻碍解析，返回JS，继续解析，返回CSS开始构建CSSOM
```



### 外链资源下载

**静态资源**：CSS样式资源、JS脚本资源、img图片类资源 遇到外链时会单独开启下载线程下载资源，每一个资源的下载都要开启一个http请求，对应一个tcp/ip链接 

CSS样式资源处理特点：

- CSS下载时异步，不会阻塞浏览器构建DOM树
- 但是会**阻塞渲染**，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）
- 有例外，media query声明的CSS是不会阻塞渲染的 

JS脚本资源的处理特点：

- **阻塞浏览器的解析**，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML
- 浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已
- **defer与async**，普通的脚本是会阻塞浏览器解析的，但是可以加上defer（延迟执行）或async（异步执行）属性，这样脚本就变成异步了，可以等到解析完毕后再执行 

img图片类资源处理特点：

- 直接就是异步下载，不会**阻塞解析**，下载完毕后直接用图片替换原有src的地方

## ⭐️⭐️当输入url到地址栏时发生了什么

>详细参考 https://segmentfault.com/a/1190000013662126

简答：

1. 浏览器地址栏输入 URL 并回车，浏览器内核进程会创建一个**异步请求线程**
2. 浏览器查找当前 URL 是否存在缓存，并比较缓存是否过期
3. DNS 解析 URL 对应的 IP，递归和迭代查询得到url对应的ip地址。
4. 找到ip地址后，进行TCP/IP请求，通过**三次握手**建立稳定连接
5. 发送 http 请求，后台接受到请求，格式等符合要求则返回数据。
6. 服务器处理请求，浏览器接受 HTTP 响应
7. **浏览器解析并渲染页面**
8. 关闭 TCP 连接（四次握手）

---

详细：

1. 从浏览器接收url到开启网络请求线程：浏览器进程/线程模型，JS的运行机制

2. 开启网络线程到发出一个完整的http请求：dns查询 tcp/ip请求 五层因特网协议栈

3. 从服务器接收到请求到对应后台接收到请求：负载均衡，安全拦截以及后台内部的处理等等

4. 后台和前台的http交互 ：http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等

5. 单独拎出来的缓存问题：http的缓存 http缓存头部，etag，catch-contro

6. 浏览器接收到http数据包后的**页面解析流程**页面渲染：
解析html词法分析然后解析成dom树、解析css生成css规则树、合并成render树、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloade

7. CSS的可视化格式模型： **CSS的可视化格式模型**规定了浏览器在页面中如何处理文档树。

   CSS中规定每一个元素都有自己的盒子模型（相当于规定了这个元素如何显示）

   然后可视化格式模型则是把这些盒子按照规则摆放到页面上，也就是如何布局

   换句话说，盒子模型规定了怎么在页面里摆放盒子，盒子的相互作用等

8. JS引擎解析过程：JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等

9. 其它，如跨域，web安全，hybrid模式等等

## JS引擎解析过程

1. 解释阶段
2. 预处理阶段：变量提升、分号补全等
3. 执行阶段

- 执行上下文，执行堆栈（如全局上下文，当前活动上下文） 每一个**执行上下文**都有三个属性：
  - VO（变量对象）和 AO（活动对象）
  - 作用域链
  - this机制 活动对象为当函数被调用者激活时创建 可以理解为： 在函数上下文中：VO = AO 在全局上下文中：VO = this === global

## 回流和重绘

- Layout，也称为Reflow，即回流。一般意味着元素的**内容、结构、位置或尺寸**发生了变化，需要重新计算样式和渲染树
  - 页面首次渲染
  - 浏览器窗口大小发生改变
  - 元素尺寸或位置发生改变
  - 元素内容变化（文字数量或图片大小等等）
  - 元素字体大小变化
  - 添加或者删除**可见**的`DOM`元素
  - 激活`CSS`伪类（例如：`:hover`）
  - 查询某些属性或调用某些方法
- Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些**外观**之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了

### 为什么会引起回流？

1.页面渲染初始化 

2.DOM结构改变，比如删除了某个节点

 3.render树变化，比如减少了padding 

4.窗口resize 

5.最复杂的一种：获取某些属性，引发回流， 很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流， 但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括

```
(1)offset(Top/Left/Width/Height)
(2) scroll(Top/Left/Width/Height)
(3) cilent(Top/Left/Width/Height)
(4) width,height
(5) 调用了getComputedStyle()或者IE的currentStyle
```

回流一定伴随着重绘，重绘却可以单独出现 回流优化，如：

- 减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新
- 避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document
- 避免多次读取offset等属性。无法避免则将它们缓存到变量
- 将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高

## 渲染优化

> 回流&重绘

目前，大多数设备的刷新率都是 60 FPS，如果浏览器在交互的过程中能够时刻保持在 60FPS 左右，用户就不会感到卡顿，否则，就会影响用户的体验。

下图为浏览器运行的单个帧的渲染流水线，称为**像素管道**，如果其中的一个或多个环节执行时间过长就会导致卡顿。像素管道是作为开发者能够掌握的对帧性能有影响的部分，其他部分由浏览器掌握，我们无法控制。我们的目标就是就是尽快完成这些环节，以达到 60 FPS 的目标。

<span><img src="https://user-images.githubusercontent.com/12322740/35977364-e9d50176-0d1d-11e8-8e47-191d277e14a2.png"></span>

JS，Style 和 Composite 是不可避免的，因为需要 JS 来引发样式的改变，

Style 来计算更改后最终的样式，

Composite 来合成各个层最终进行显示。

Layout 和 Paint 这两个步骤不一定会被触发，所以在优化的过程中，如果是需要频繁触发的改变，我们**应该尽可能避免 Layout 和 Paint**。

1. 使用 requestAnimationFrame（），这个函数在每一帧被调用，将 JS 分块到每一帧，在每一帧结束时，归还主线程
2. 尽量使用 transform 和 obacity 属性更改来实现动画
3. 减小选择器匹配的难度
4. 提升元素到新的层（不能滥用）

## 渐进式渲染

**渐进式渲染是用来提高网页性能，以尽快呈现页面的技术。** 

- 图片懒加载——页面上的图片不会一次性的全部加载，当用户滚动页面到图片位置时，JS将加载并显示图像。
- 确定显示内容的优先级——为了尽快将页面呈现给用户，页面只将一小部分CSS，脚本，内容加载，然后在延时加载或者监听事件来加载。
- 异步加载HTML片段——当页面通过后台渲染时，把HTML拆分，通过异步请求，分块发送给浏览器。

## ⭐️cookie和session的区别

```
参考：https://juejin.cn/post/6844904115080790023
```

cookie:客户端

session：服务端

服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 sessionId ，并通过响应头的 **Set-Cookie：JSESSIONID=XXXXXXX **命令，向客户端发送要求设置 Cookie 的响应； 客户端收到响应后，在本机客户端设置了一个 **JSESSIONID=XXXXXXX **的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束；

Cookie 主要用于下面三个目的

- 会话管理

登陆、购物车、游戏得分或者服务器应该记住的其他内容

- 个性化

用户偏好、主题或者其他设置

- 追踪

记录和分析用户行为





